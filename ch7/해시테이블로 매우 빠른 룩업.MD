## 7.1 해시 테이블 소개
💿 hash table은 자료구조를 포함하며 빠른 읽기의 능력을 가지고 있다. 
   hash table은 key와 value로 이루어진 리스트이다. 
   food = {1: 'chicken', 2: 'soup', 3: 'pizza'}
   1은 key이고 'chicken은 value이다. 
   print(food[1])을 하게 되면 1에 있는 value chicken이 출력된다. 

🧊 hash table의 값 룩업은 한 단계만 걸리므로 평균적으로 효율성이 O(1)이다.

## 7.2 해시 테이블 해싱
A = 1 
B = 2
C = 3
D = 4
E = 5 

💿 ACE는 135 
💿 CAB는 312 
💿 DAB는 412로 변환된다. 
   ⏩ 문자를 가져와 숫자로 변환하는 과정을 해싱이라 부르고 
   ⏩ 글자를 특정 숫자로 변환하는 데 사용한 코드를 해시 함수라 부른다.

1 단계: 먼저 BAD를 214로 변환한다. 
2 단계: 각 숫자를 갖와 합한다. 
 2 + 1 + 4 = 7 

또 다른 해시 함수 예제는 문자에 해당하는 모든 수를 곱해서 반환하는 것이다. 
    🧊 BAD 숫자 8로 변환 

1 단계: 먼저 BAD를 214로 변환하다. 
2 단계: 각 숫자를 가져와 곱한다. 
 2 X 4 X 1 = 8 

그리고 딱 한 가지 기준을 충족해야 함! 
[✅] 해시 함수는 동일한 문자열을 해시 함수에 적용할 때마다 항상 동일한 숫자로 변환해야 한다. 
[🧊] 2 * 1 * 4 = 항상 8이다. 

## 7.3 재미와 이익, 특히 이익을 남길 유의어 사전 만들기
[📀] 사전 만들기 
thesaurus = {}      
첫 번째 항목을 해시에 추가해 보자. 
thesaurus["bad"] = "evil" 
{"bad" => "evil"}

해시 테이블이 데이터를 어떻게 저장할까?
먼저 컴퓨터는 키에 해시 함수를 적용한다 => 곱셈 해시 함수 사용 
BAD = 2*1*4 = 8 
키 ("BAD")는 8로 해싱되므로 컴퓨터는 값 ("evil")을 다음과 같이 셀 8에 넣는다. 
[][][][][][][]["evil"][][][][][][][][][][]

이제 다른 키/값 쌍을 추가해 보자.
thesaurus["cab"] = "taxi" 
다시 한번 컴퓨터는 키를 해싱한다. 
CAB = 3*1*2 = 6
결과 값이 6이므로 컴퓨터는 값 ("taxi")를 셀 6에 저장한다. 
[][][][][]["taxi"][]["evil"][][][][][][][][][][]

다른 키/값 쌍을 하나 더 추가해 보자.
thesaurus["ace"] = "star"
[][][][][]["taxi"][]["evil"][][][][][][][][]["star"][]

코드로 표현하면 해시 테이블은 현재 다음과 같다.
{"bad" => "evil", "cab" => "taxi", "ace" => "star"}
이제 값을 어떻게 룩업하는지 알아보자. 
키 "bad"의 값을 룩업하면 thesaurus["bad"] 

1. 컴퓨터는 룩업하고 있는 키를 해싱한다.BAD = 2*1*4 = 8
2. 결과는 8이므로 셀 8을 찾아가서 저장된 값을 반환한다. 여기서 문자열 "evil"이다. 

🧊 해시 테이블을 쓰면 실제 메뉴 항목을 키로 사용해서 해시 테이블 룩업을 O(1)만에 할 수 있다. 

## 7.4 충돌 해결
만들었던 유의어 사전 예제를 계속 살펴보자. 
thesaurus["dab"] = "pat" 

먼저 컴퓨터는 키를 해싱할 것이다. 
DAB = 4*1*2 = 8

그리고 "PAT"를 해시 테이블 셀 8에 추가하려 할 것이지만 
이미 셀 8에 "evil"이 들어 있다... 
[][][][][]["taxi"][]["evil"][][][][][][][][]["star"][]
이것을 충돌이라 부른다. 
충돌을 해결하는 고전적인 방법 하나가 분리 연결법이다. 
충돌이 발생했을 때 셀에 하나의 값을 넣는 대신 배열로의 참조를 넣는 방법이다. 

해시 테이블의 내부 데이터 저장소 일부를 좀 더 자세히 들여다보자. 
[5][6["taxi"]][7][8["evil"]][9]
예제에서 컴퓨터는 셀 8에 "pat"을 추가하려 했지만 이미 "evil"이 들어있다. 
따라서 셀 8을 그림 7-7에 나오는 배열로 대체한다. 

이 배열에 포함된 하위 배열의 첫 번째 값은 단어, 두 번째 단어는 그 단어의 동의어다. 
[7][["bad"|"evil]["dab"|"pat"]][9]
자 이렇게 바꿨을 때 해시 테이블 룩업이 어떻게 동작하는지 차례대로 살펴보자.
thesaurus["dab"]을 룩업할 때 컴퓨터는 다음과 같은 단계를 밟는다. 

1. 컴퓨터는 키를 해싱한다. DAB = 4*1*2 = 8
2. 셀 8을 룩업한다. 컴퓨터는 셀 8이 하나의 값이 아닌 배열들의 배열을 포함하고 있음을 알게된다. 
3. 각 학위 배열의 인덱스 0을 찾아보며 룩업하고 있는 단어인("dab")을 찾을 때까지 배열을 차례대로 검색 
   ⏩ 일치하는 하위 배열의 인덱스 1에 있는 값을 반환 

💿 DAB이 8로 해싱되므로 컴퓨터는 그 셀을 찾아본다. 
셀 8은 배열을 포함하므로 첫 번째 셀부터 시작해서 각 셀을 선형 검색한다. (인덱스 0 확인)
["bad"]["evil"] 인덱스 0에 찾고있는 단어 "dab"가 없으므로 다음 셀로 넘어간다. 
["dab]["pat"] 오.. "dab"를 찾았다. 인덱스 1에 있는 값인("pat")가 바로 찾고 있던 값이다. 

📀 컴퓨터가 확인 중인 셀이 배열을 참조할 경우 다수의 값이 들어 있는 배열을 선형 검색해야 하므로.. 
   사실상 해시 테이블 룩업 성능 (최악의 경우) O(N)이다.
   이렇기 때문에 O(1)시간 내에 일반적으로 룩업을 수행하도록 디자인해야 한다. 
   
## 7.5 훌륭한 충돌 조정
해시 테이블의 효율성 3가지 
1. 해시 테이블에 얼마나 많은 데이터를 저장하는가
2. 해시 테이블에서 얼마나 많은 셀을 쓸 수 있는가
3. 어떤 해시 함수를 사용하는가 

PUT = 16 + 21 + 20 = 57 
57은 숫자가 둘 이상이므로 해시 함수는 57을 5 + 7로 쪼갠다. 
5 + 7 = 12 
12도 숫자가 둘 이상이므로 해시 함수는 12를 1 + 2로 쪼갠다. 
1 + 2 = 3
PUT은 3으로 해싱된다. 위 해시 함수는 본질적으로 항상 1과 9사이에 숫자를 반환하게끔 돼 있다. 

🧊 해시 테이블은 반드시 충돌 조정을 수행해야 한다.
   좋은 해시 테이블은 많은 메모리를 낭비하지 않으면서 균형을 유지하며 충돌을 피한다. 

충돌 조정을 위해 규칙을 세웠다!
해시 테이블에 저장된 데이터가 7개면 셀은 10개여야 한다.
다시 말해 원소 14개를 저장할 생각이라면 셀이 20개가 있어야 하는 등이다.

데이터와 셀 간 이러한 비율을 부하율이라 부른다. 
이상적인 부하율은 0.7이라 말할 수 있다. 

## 7.6 실제 예제 
🧊 예제 
// votes push O(1)
var votes = [];

function addVote(candidate){
    votes.push(candidate);
}

// votes countVotes O(N)
function countVotes(votes){
    var tally = {};
    for(var i = 0; i < votes.length; i++){
        if(tally[votes[i]]){
            tally[votes[i]]++;
        }
        else {
            tally[votes[i]] = 1;
        }
    }
    return tally;
}

// advote O(1)
function adVote(candidate){
    if(votes[candidate]){
        votes[candidate]++;
    }
    else{
        votes[candidate] = 1;
    }
}

// 투표 배열 
addVote('Candidate A');
addVote('Candidate B');
addVote('Candidate A');
addVote('Candidate C');
addVote('Candidate A');

// countVotes  
var voteTally = countVotes(votes);
console.log('Vote Tally:', voteTally);

// adVote  
adVote('Candidate B');
adVote('Candidate B');
adVote('Candidate C');
adVote('Candidate C');

console.log('Updated Votes:', votes);

🥤 2번 함수 빼고 1,3번 함수는 O(1)이 걸린다. 

## 7.7 마무리
해시 테이블은 효율적인 소프트웨어 개발에 필수로 
O(1) 읽기와 삽입은 쉽게 따라잡을 수 없는 자료 구조다. 